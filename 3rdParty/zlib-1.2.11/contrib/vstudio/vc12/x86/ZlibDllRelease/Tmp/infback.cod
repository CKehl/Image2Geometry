; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\git\Image2Geometry\3rdParty\zlib-1.2.11\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	_inflate_fast:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+1
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+2
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	_inflateBackEnd@4
PUBLIC	_inflateBack@20
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Ogtp
; File d:\git\image2geometry\3rdparty\zlib-1.2.11\infback.c
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 c0 00 00
	00		 je	 $LN6@inflateBac
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 b7 00 00
	00		 jne	 $LN6@inflateBac
  00017	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 ad 00 00
	00		 jne	 $LN6@inflateBac

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00026	57		 push	 edi
  00027	85 f6		 test	 esi, esi
  00029	0f 84 93 00 00
	00		 je	 $LN4@inflateBac
  0002f	8b 5d 10	 mov	 ebx, DWORD PTR _window$[ebp]
  00032	85 db		 test	 ebx, ebx
  00034	0f 84 88 00 00
	00		 je	 $LN4@inflateBac
  0003a	8b 7d 0c	 mov	 edi, DWORD PTR _windowBits$[ebp]
  0003d	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00040	83 f8 07	 cmp	 eax, 7
  00043	77 7d		 ja	 SHORT $LN4@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00045	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00049	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00050	75 0e		 jne	 SHORT $LN3@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00059	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN3@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00060	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00064	75 07		 jne	 SHORT $LN2@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  00066	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN2@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  0006d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00070	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00075	6a 01		 push	 1
  00077	ff 76 28	 push	 DWORD PTR [esi+40]
  0007a	ff d0		 call	 eax
  0007c	8b d0		 mov	 edx, eax
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  00081	85 d2		 test	 edx, edx
  00083	75 0a		 jne	 SHORT $LN1@inflateBac
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0008a	5b		 pop	 ebx

; 70   : }

  0008b	5d		 pop	 ebp
  0008c	c2 14 00	 ret	 20			; 00000014H
$LN1@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  0008f	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  00092	8b cf		 mov	 ecx, edi
  00094	89 7a 28	 mov	 DWORD PTR [edx+40], edi
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	5f		 pop	 edi
  0009d	d3 e0		 shl	 eax, cl
  0009f	5e		 pop	 esi
  000a0	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 66   :     state->window = window;
; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;
; 69   :     return Z_OK;

  000a3	33 c0		 xor	 eax, eax
  000a5	89 5a 38	 mov	 DWORD PTR [edx+56], ebx
  000a8	c7 42 18 00 80
	00 00		 mov	 DWORD PTR [edx+24], 32768 ; 00008000H
  000af	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
  000b6	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
  000bd	5b		 pop	 ebx

; 70   : }

  000be	5d		 pop	 ebp
  000bf	c2 14 00	 ret	 20			; 00000014H
$LN4@inflateBac:
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi

; 42   :         return Z_STREAM_ERROR;

  000c4	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000c9	5b		 pop	 ebx

; 70   : }

  000ca	5d		 pop	 ebp
  000cb	c2 14 00	 ret	 20			; 00000014H
$LN6@inflateBac:

; 39   :         return Z_VERSION_ERROR;

  000ce	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 70   : }

  000d3	5d		 pop	 ebp
  000d4	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\git\image2geometry\3rdparty\zlib-1.2.11\infback.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 121  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 123  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\git\image2geometry\3rdparty\zlib-1.2.11\infback.c
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv1685 = -48						; size = 4
tv1684 = -48						; size = 4
tv1683 = -48						; size = 4
$T1 = -44						; size = 4
tv1677 = -44						; size = 4
tv1675 = -44						; size = 4
tv1674 = -44						; size = 4
tv1688 = -40						; size = 4
_len$1$ = -36						; size = 4
_here$1$ = -36						; size = 4
_copy$4$ = -32						; size = 4
_last$ = -32						; size = 4
_here$ = -32						; size = 4
_put$1$ = -28						; size = 4
_left$1$ = -24						; size = 4
_bits$1$ = -20						; size = 4
_next$5$ = -16						; size = 4
_state$1$ = -12						; size = 4
_next$ = -8						; size = 4
_hold$1$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 30	 sub	 esp, 48			; 00000030H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 b7 0d 00
	00		 je	 $LN333@inflateBac
  00011	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00014	89 55 f4	 mov	 DWORD PTR _state$1$[ebp], edx
  00017	85 d2		 test	 edx, edx
  00019	0f 84 a9 0d 00
	00		 je	 $LN333@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  0001f	53		 push	 ebx
  00020	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 279  :     state->mode = TYPE;

  00027	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 280  :     state->last = 0;

  0002e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  :     state->whave = 0;

  00035	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 282  :     next = strm->next_in;

  0003c	8b 18		 mov	 ebx, DWORD PTR [eax]
  0003e	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00041	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00044	56		 push	 esi
  00045	57		 push	 edi

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00046	85 db		 test	 ebx, ebx
  00048	74 05		 je	 SHORT $LN337@inflateBac
  0004a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0004d	eb 02		 jmp	 SHORT $LN338@inflateBac
$LN337@inflateBac:
  0004f	33 f6		 xor	 esi, esi
$LN338@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;

  00051	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00054	33 c9		 xor	 ecx, ecx
  00056	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00059	33 ff		 xor	 edi, edi

; 287  :     left = state->wsize;

  0005b	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0005e	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00069	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  0006c	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0006f	83 f8 12	 cmp	 eax, 18			; 00000012H
  00072	0f 87 b9 0c 00
	00		 ja	 $LN1@inflateBac
  00078	8b 5d f0	 mov	 ebx, DWORD PTR _next$5$[ebp]
  0007b	eb 03 8d 49 00	 npad	 5
$LL332@inflateBac:
  00080	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN465@inflateBac[eax]
  00087	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN497@inflateBac[eax*4]
$LN328@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  0008e	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00092	74 19		 je	 SHORT $LN323@inflateBac

; 295  :                 BYTEBITS();

  00094	8b cf		 mov	 ecx, edi

; 296  :                 state->mode = DONE;

  00096	c7 42 04 50 3f
	00 00		 mov	 DWORD PTR [edx+4], 16208 ; 00003f50H
  0009d	83 e1 07	 and	 ecx, 7
  000a0	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  000a3	2b f9		 sub	 edi, ecx
  000a5	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 297  :                 break;

  000a8	e9 6a 0c 00 00	 jmp	 $LN495@inflateBac
$LN323@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000ad	83 ff 03	 cmp	 edi, 3
  000b0	73 3d		 jae	 SHORT $LN322@inflateBac
$LL320@inflateBac:
  000b2	85 f6		 test	 esi, esi
  000b4	75 1a		 jne	 SHORT $LN314@inflateBac
  000b6	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  000b9	50		 push	 eax
  000ba	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  000bd	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  000c0	8b f0		 mov	 esi, eax
  000c2	83 c4 08	 add	 esp, 8
  000c5	85 f6		 test	 esi, esi
  000c7	0f 84 7f 0c 00
	00		 je	 $LN363@inflateBac
  000cd	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
$LN314@inflateBac:
  000d0	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000d3	8b cf		 mov	 ecx, edi
  000d5	d3 e0		 shl	 eax, cl
  000d7	43		 inc	 ebx
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  000db	83 c7 08	 add	 edi, 8
  000de	03 c8		 add	 ecx, eax
  000e0	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  000e3	4e		 dec	 esi
  000e4	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  000e7	83 ff 03	 cmp	 edi, 3
  000ea	72 c6		 jb	 SHORT $LL320@inflateBac
  000ec	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN322@inflateBac:

; 300  :             state->last = BITS(1);

  000ef	8b c1		 mov	 eax, ecx

; 301  :             DROPBITS(1);

  000f1	d1 e9		 shr	 ecx, 1
  000f3	83 e0 01	 and	 eax, 1
  000f6	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  000f9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 302  :             switch (BITS(2)) {

  000fc	8b c1		 mov	 eax, ecx
  000fe	83 e0 03	 and	 eax, 3
  00101	83 f8 03	 cmp	 eax, 3
  00104	77 3d		 ja	 SHORT $LN301@inflateBac
  00106	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN498@inflateBac[eax*4]
$LN305@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  0010d	c7 42 04 41 3f
	00 00		 mov	 DWORD PTR [edx+4], 16193 ; 00003f41H

; 307  :                 break;

  00114	eb 2d		 jmp	 SHORT $LN301@inflateBac
$LN304@inflateBac:

; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00116	8b ca		 mov	 ecx, edx
  00118	e8 00 00 00 00	 call	 _fixedtables

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  00120	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
  00127	eb 1a		 jmp	 SHORT $LN301@inflateBac
$LN303@inflateBac:

; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  00129	c7 42 04 44 3f
	00 00		 mov	 DWORD PTR [edx+4], 16196 ; 00003f44H

; 318  :                 break;

  00130	eb 11		 jmp	 SHORT $LN301@inflateBac
$LN302@inflateBac:

; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00132	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00135	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;

  0013c	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H
$LN301@inflateBac:

; 322  :             }
; 323  :             DROPBITS(2);
; 324  :             break;

  00143	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00146	c1 e9 02	 shr	 ecx, 2
  00149	83 ef 03	 sub	 edi, 3
  0014c	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  0014f	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00152	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00155	e9 c6 0b 00 00	 jmp	 $LN387@inflateBac
$LN297@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  0015a	8b cf		 mov	 ecx, edi
  0015c	83 e1 07	 and	 ecx, 7
  0015f	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  00162	2b f9		 sub	 edi, ecx
  00164	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 329  :             NEEDBITS(32);

  00167	83 ff 20	 cmp	 edi, 32			; 00000020H
  0016a	73 46		 jae	 SHORT $LN483@inflateBac
  0016c	8d 64 24 00	 npad	 4
$LL291@inflateBac:
  00170	85 f6		 test	 esi, esi
  00172	75 1a		 jne	 SHORT $LN285@inflateBac
  00174	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00177	50		 push	 eax
  00178	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0017b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0017e	8b f0		 mov	 esi, eax
  00180	83 c4 08	 add	 esp, 8
  00183	85 f6		 test	 esi, esi
  00185	0f 84 c1 0b 00
	00		 je	 $LN363@inflateBac
  0018b	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
$LN285@inflateBac:
  0018e	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00191	8b cf		 mov	 ecx, edi
  00193	d3 e0		 shl	 eax, cl
  00195	83 c7 08	 add	 edi, 8
  00198	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  0019b	43		 inc	 ebx
  0019c	03 c8		 add	 ecx, eax
  0019e	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  001a1	4e		 dec	 esi
  001a2	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  001a5	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  001a8	83 ff 20	 cmp	 edi, 32			; 00000020H
  001ab	72 c3		 jb	 SHORT $LL291@inflateBac
  001ad	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  001b0	eb 03		 jmp	 SHORT $LN293@inflateBac
$LN483@inflateBac:
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
$LN293@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001b5	8b c1		 mov	 eax, ecx
  001b7	8b d9		 mov	 ebx, ecx
  001b9	f7 d0		 not	 eax
  001bb	81 e3 ff ff 00
	00		 and	 ebx, 65535		; 0000ffffH
  001c1	c1 e8 10	 shr	 eax, 16			; 00000010H
  001c4	3b d8		 cmp	 ebx, eax
  001c6	74 1c		 je	 SHORT $LN281@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  001c8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001cb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 332  :                 state->mode = BAD;

  001d2	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 333  :                 break;

  001d9	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  001dc	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  001df	e9 3c 0b 00 00	 jmp	 $LN387@inflateBac
$LN281@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;
; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  001e4	33 c9		 xor	 ecx, ecx
  001e6	89 5a 44	 mov	 DWORD PTR [edx+68], ebx
  001e9	33 ff		 xor	 edi, edi
  001eb	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  001ee	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  001f1	3b d9		 cmp	 ebx, ecx
  001f3	0f 84 88 00 00
	00		 je	 $LN276@inflateBac
  001f9	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  001fc	8d 64 24 00	 npad	 4
$LL277@inflateBac:

; 342  :                 copy = state->length;

  00200	8b 5a 44	 mov	 ebx, DWORD PTR [edx+68]

; 343  :                 PULL();

  00203	85 f6		 test	 esi, esi
  00205	75 1d		 jne	 SHORT $LN274@inflateBac
  00207	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0020a	50		 push	 eax
  0020b	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0020e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00211	8b f0		 mov	 esi, eax
  00213	83 c4 08	 add	 esp, 8
  00216	85 f6		 test	 esi, esi
  00218	0f 84 2e 0b 00
	00		 je	 $LN363@inflateBac
  0021e	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00221	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN274@inflateBac:

; 344  :                 ROOM();

  00224	85 c0		 test	 eax, eax
  00226	75 25		 jne	 SHORT $LN269@inflateBac
  00228	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  0022b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0022e	51		 push	 ecx
  0022f	50		 push	 eax
  00230	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00233	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00236	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00239	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
  0023c	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00242	85 c0		 test	 eax, eax
  00244	0f 85 1c 0b 00
	00		 jne	 $LN366@inflateBac
  0024a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN269@inflateBac:

; 345  :                 if (copy > have) copy = have;

  0024d	3b de		 cmp	 ebx, esi
  0024f	0f 47 de	 cmova	 ebx, esi

; 346  :                 if (copy > left) copy = left;

  00252	3b d8		 cmp	 ebx, eax
  00254	0f 47 d8	 cmova	 ebx, eax

; 347  :                 zmemcpy(put, next, copy);

  00257	8b 45 e4	 mov	 eax, DWORD PTR _put$1$[ebp]
  0025a	53		 push	 ebx
  0025b	ff 75 f8	 push	 DWORD PTR _next$[ebp]
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 _memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;
; 350  :                 left -= copy;
; 351  :                 put += copy;
; 352  :                 state->length -= copy;

  00264	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0026d	2b f3		 sub	 esi, ebx
  0026f	01 5d f8	 add	 DWORD PTR _next$[ebp], ebx
  00272	2b c3		 sub	 eax, ebx
  00274	01 5d e4	 add	 DWORD PTR _put$1$[ebp], ebx
  00277	29 5a 44	 sub	 DWORD PTR [edx+68], ebx
  0027a	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  0027d	75 81		 jne	 SHORT $LL277@inflateBac
  0027f	8b cf		 mov	 ecx, edi
$LN276@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  00281	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 356  :             break;

  00288	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  0028b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0028e	e9 8d 0a 00 00	 jmp	 $LN387@inflateBac
$LN262@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  00293	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  00296	73 38		 jae	 SHORT $LN261@inflateBac
$LL259@inflateBac:
  00298	85 f6		 test	 esi, esi
  0029a	75 1a		 jne	 SHORT $LN253@inflateBac
  0029c	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0029f	50		 push	 eax
  002a0	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  002a3	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  002a6	8b f0		 mov	 esi, eax
  002a8	83 c4 08	 add	 esp, 8
  002ab	85 f6		 test	 esi, esi
  002ad	0f 84 99 0a 00
	00		 je	 $LN363@inflateBac
  002b3	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
$LN253@inflateBac:
  002b6	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  002b9	8b cf		 mov	 ecx, edi
  002bb	d3 e0		 shl	 eax, cl
  002bd	43		 inc	 ebx
  002be	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  002c1	83 c7 08	 add	 edi, 8
  002c4	4e		 dec	 esi
  002c5	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  002c8	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  002cb	72 cb		 jb	 SHORT $LL259@inflateBac
  002cd	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN261@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  002d0	8b 5d fc	 mov	 ebx, DWORD PTR _hold$1$[ebp]

; 362  :             DROPBITS(5);
; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  002d3	83 ef 0e	 sub	 edi, 14			; 0000000eH
  002d6	8b c3		 mov	 eax, ebx
  002d8	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  002db	83 e0 1f	 and	 eax, 31			; 0000001fH
  002de	c1 eb 05	 shr	 ebx, 5
  002e1	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002e6	89 42 64	 mov	 DWORD PTR [edx+100], eax
  002e9	8b c3		 mov	 eax, ebx
  002eb	83 e0 1f	 and	 eax, 31			; 0000001fH
  002ee	c1 eb 05	 shr	 ebx, 5
  002f1	40		 inc	 eax
  002f2	89 42 68	 mov	 DWORD PTR [edx+104], eax
  002f5	8b c3		 mov	 eax, ebx
  002f7	83 e0 0f	 and	 eax, 15			; 0000000fH
  002fa	c1 eb 04	 shr	 ebx, 4
  002fd	83 c0 04	 add	 eax, 4
  00300	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00303	81 7a 64 1e 01
	00 00		 cmp	 DWORD PTR [edx+100], 286 ; 0000011eH
  0030a	89 42 60	 mov	 DWORD PTR [edx+96], eax
  0030d	0f 87 16 05 00
	00		 ja	 $LN239@inflateBac
  00313	83 7a 68 1e	 cmp	 DWORD PTR [edx+104], 30	; 0000001eH
  00317	0f 87 0c 05 00
	00		 ja	 $LN239@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0031d	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0

; 378  :             while (state->have < state->ncode) {

  00324	85 c0		 test	 eax, eax
  00326	76 6b		 jbe	 SHORT $LN346@inflateBac
$LL238@inflateBac:

; 379  :                 NEEDBITS(3);

  00328	83 ff 03	 cmp	 edi, 3
  0032b	73 3a		 jae	 SHORT $LN235@inflateBac
  0032d	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LL233@inflateBac:
  00330	85 f6		 test	 esi, esi
  00332	75 1a		 jne	 SHORT $LN227@inflateBac
  00334	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00337	50		 push	 eax
  00338	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0033b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0033e	8b f0		 mov	 esi, eax
  00340	83 c4 08	 add	 esp, 8
  00343	85 f6		 test	 esi, esi
  00345	0f 84 01 0a 00
	00		 je	 $LN363@inflateBac
  0034b	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LN227@inflateBac:
  0034e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00351	8b cf		 mov	 ecx, edi
  00353	d3 e0		 shl	 eax, cl
  00355	42		 inc	 edx
  00356	83 c7 08	 add	 edi, 8
  00359	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0035c	4e		 dec	 esi
  0035d	03 d8		 add	 ebx, eax
  0035f	83 ff 03	 cmp	 edi, 3
  00362	72 cc		 jb	 SHORT $LL233@inflateBac
  00364	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN235@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00367	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0036a	8b cb		 mov	 ecx, ebx
  0036c	83 e1 07	 and	 ecx, 7

; 381  :                 DROPBITS(3);

  0036f	c1 eb 03	 shr	 ebx, 3
  00372	83 ef 03	 sub	 edi, 3
  00375	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx
  00378	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0037b	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]
  00383	66 89 4c 42 74	 mov	 WORD PTR [edx+eax*2+116], cx
  00388	ff 42 6c	 inc	 DWORD PTR [edx+108]
  0038b	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0038e	3b 42 60	 cmp	 eax, DWORD PTR [edx+96]
  00391	72 95		 jb	 SHORT $LL238@inflateBac
$LN346@inflateBac:

; 382  :             }
; 383  :             while (state->have < 19)

  00393	83 7a 6c 13	 cmp	 DWORD PTR [edx+108], 19	; 00000013H
  00397	73 22		 jae	 SHORT $LN219@inflateBac
  00399	8d a4 24 00 00
	00 00		 npad	 7
$LL220@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  003a0	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  003a3	33 c9		 xor	 ecx, ecx
  003a5	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]
  003ad	66 89 4c 42 74	 mov	 WORD PTR [edx+eax*2+116], cx
  003b2	ff 42 6c	 inc	 DWORD PTR [edx+108]
  003b5	83 7a 6c 13	 cmp	 DWORD PTR [edx+108], 19	; 00000013H
  003b9	72 e5		 jb	 SHORT $LL220@inflateBac
$LN219@inflateBac:

; 385  :             state->next = state->codes;

  003bb	8d 82 34 05 00
	00		 lea	 eax, DWORD PTR [edx+1332]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  003c1	c7 42 58 07 00
	00 00		 mov	 DWORD PTR [edx+88], 7
  003c8	8d 4a 70	 lea	 ecx, DWORD PTR [edx+112]
  003cb	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  003ce	8d 9a f4 02 00
	00		 lea	 ebx, DWORD PTR [edx+756]
  003d4	89 01		 mov	 DWORD PTR [ecx], eax
  003d6	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  003d9	83 c2 74	 add	 edx, 116		; 00000074H
  003dc	53		 push	 ebx
  003dd	50		 push	 eax
  003de	51		 push	 ecx
  003df	6a 13		 push	 19			; 00000013H
  003e1	33 c9		 xor	 ecx, ecx
  003e3	89 45 d8	 mov	 DWORD PTR tv1688[ebp], eax
  003e6	89 55 d0	 mov	 DWORD PTR tv1685[ebp], edx
  003e9	e8 00 00 00 00	 call	 _inflate_table

; 392  :                 state->mode = BAD;

  003ee	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  003f1	83 c4 10	 add	 esp, 16			; 00000010H
  003f4	85 c0		 test	 eax, eax
  003f6	74 16		 je	 SHORT $LN218@inflateBac

; 390  :             if (ret) {
; 391  :                 strm->msg = (char *)"invalid code lengths set";

  003f8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  003fb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 392  :                 state->mode = BAD;

  00402	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 393  :                 break;

  00409	e9 09 09 00 00	 jmp	 $LN495@inflateBac
$LN218@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0040e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00411	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0
  00418	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  0041b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0041e	03 42 64	 add	 eax, DWORD PTR [edx+100]
  00421	0f 84 8c 02 00
	00		 je	 $LN216@inflateBac
  00427	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL217@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  00430	8b 45 d8	 mov	 eax, DWORD PTR tv1688[ebp]
  00433	ba 01 00 00 00	 mov	 edx, 1
  00438	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043a	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0043d	d3 e2		 shl	 edx, cl
  0043f	4a		 dec	 edx
  00440	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00443	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00446	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00449	8b c8		 mov	 ecx, eax
  0044b	c1 e9 08	 shr	 ecx, 8
  0044e	0f b6 c9	 movzx	 ecx, cl
  00451	89 45 dc	 mov	 DWORD PTR _here$1$[ebp], eax
  00454	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  00457	3b cf		 cmp	 ecx, edi
  00459	76 63		 jbe	 SHORT $LN369@inflateBac
  0045b	eb 03 8d 49 00	 npad	 5
$LL215@inflateBac:

; 403  :                     PULLBYTE();

  00460	85 f6		 test	 esi, esi
  00462	75 1a		 jne	 SHORT $LN208@inflateBac
  00464	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00467	50		 push	 eax
  00468	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0046b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0046e	8b f0		 mov	 esi, eax
  00470	83 c4 08	 add	 esp, 8
  00473	85 f6		 test	 esi, esi
  00475	0f 84 d1 08 00
	00		 je	 $LN363@inflateBac
  0047b	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
$LN208@inflateBac:
  0047e	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00481	8b cf		 mov	 ecx, edi
  00483	d3 e0		 shl	 eax, cl
  00485	43		 inc	 ebx
  00486	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00489	ba 01 00 00 00	 mov	 edx, 1
  0048e	8b 45 d8	 mov	 eax, DWORD PTR tv1688[ebp]
  00491	83 c7 08	 add	 edi, 8
  00494	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00497	4e		 dec	 esi
  00498	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0049b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0049d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  004a0	d3 e2		 shl	 edx, cl
  004a2	4a		 dec	 edx
  004a3	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  004a6	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  004a9	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  004ac	8b c8		 mov	 ecx, eax
  004ae	c1 e9 08	 shr	 ecx, 8
  004b1	0f b6 c9	 movzx	 ecx, cl
  004b4	89 45 dc	 mov	 DWORD PTR _here$1$[ebp], eax
  004b7	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  004ba	3b cf		 cmp	 ecx, edi
  004bc	77 a2		 ja	 SHORT $LL215@inflateBac
$LN369@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  004be	8b c8		 mov	 ecx, eax
  004c0	c1 e9 10	 shr	 ecx, 16			; 00000010H
  004c3	89 4d d4	 mov	 DWORD PTR tv1677[ebp], ecx
  004c6	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  004ca	73 24		 jae	 SHORT $LN491@inflateBac

; 406  :                     DROPBITS(here.bits);
; 407  :                     state->lens[state->have++] = here.val;

  004cc	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  004cf	c1 e8 08	 shr	 eax, 8
  004d2	0f b6 c8	 movzx	 ecx, al
  004d5	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  004d8	2b f9		 sub	 edi, ecx
  004da	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  004dd	8b 4d d4	 mov	 ecx, DWORD PTR tv1677[ebp]
  004e0	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  004e3	66 89 4c 42 74	 mov	 WORD PTR [edx+eax*2+116], cx
  004e8	ff 42 6c	 inc	 DWORD PTR [edx+108]

; 408  :                 }
; 409  :                 else {

  004eb	e9 ae 01 00 00	 jmp	 $LN492@inflateBac
$LN491@inflateBac:
  004f0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 410  :                     if (here.val == 16) {

  004f3	0f 85 96 00 00
	00		 jne	 $LN199@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  004f9	8b c8		 mov	 ecx, eax
  004fb	c1 e9 08	 shr	 ecx, 8
  004fe	0f b6 c9	 movzx	 ecx, cl
  00501	83 c1 02	 add	 ecx, 2
  00504	89 4d d4	 mov	 DWORD PTR $T1[ebp], ecx
  00507	3b f9		 cmp	 edi, ecx
  00509	73 45		 jae	 SHORT $LN197@inflateBac
  0050b	eb 03 8d 49 00	 npad	 5
$LL195@inflateBac:
  00510	85 f6		 test	 esi, esi
  00512	75 1d		 jne	 SHORT $LN189@inflateBac
  00514	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00517	50		 push	 eax
  00518	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0051b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0051e	8b f0		 mov	 esi, eax
  00520	83 c4 08	 add	 esp, 8
  00523	85 f6		 test	 esi, esi
  00525	0f 84 21 08 00
	00		 je	 $LN363@inflateBac
  0052b	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  0052e	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN189@inflateBac:
  00531	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00534	8b cf		 mov	 ecx, edi
  00536	d3 e0		 shl	 eax, cl
  00538	43		 inc	 ebx
  00539	03 d0		 add	 edx, eax
  0053b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0053e	83 c7 08	 add	 edi, 8
  00541	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00544	4e		 dec	 esi
  00545	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00548	3b 7d d4	 cmp	 edi, DWORD PTR $T1[ebp]
  0054b	72 c3		 jb	 SHORT $LL195@inflateBac
  0054d	8b 45 dc	 mov	 eax, DWORD PTR _here$1$[ebp]
$LN197@inflateBac:

; 412  :                         DROPBITS(here.bits);

  00550	0f b6 cc	 movzx	 ecx, ah
  00553	d3 ea		 shr	 edx, cl
  00555	2b f9		 sub	 edi, ecx
  00557	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 413  :                         if (state->have == 0) {

  0055a	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0055d	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00560	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00563	85 c0		 test	 eax, eax
  00565	0f 84 75 01 00
	00		 je	 $LN374@inflateBac

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  0056b	0f b7 44 42 72	 movzx	 eax, WORD PTR [edx+eax*2+114]
  00570	89 45 dc	 mov	 DWORD PTR _len$1$[ebp], eax

; 419  :                         copy = 3 + BITS(2);

  00573	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  00576	8b c8		 mov	 ecx, eax
  00578	83 e1 03	 and	 ecx, 3

; 420  :                         DROPBITS(2);

  0057b	c1 e8 02	 shr	 eax, 2
  0057e	83 c1 03	 add	 ecx, 3
  00581	89 45 fc	 mov	 DWORD PTR _hold$1$[ebp], eax
  00584	89 4d e0	 mov	 DWORD PTR _copy$4$[ebp], ecx
  00587	83 ef 02	 sub	 edi, 2

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  0058a	e9 df 00 00 00	 jmp	 $LN493@inflateBac
$LN199@inflateBac:
  0058f	66 83 7d e2 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 423  :                         NEEDBITS(here.bits + 3);

  00594	0f b6 cc	 movzx	 ecx, ah
  00597	75 63		 jne	 SHORT $LN156@inflateBac
  00599	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  0059c	89 4d d4	 mov	 DWORD PTR tv1675[ebp], ecx
  0059f	3b f8		 cmp	 edi, eax
  005a1	73 42		 jae	 SHORT $LN175@inflateBac
$LL173@inflateBac:
  005a3	85 f6		 test	 esi, esi
  005a5	75 1d		 jne	 SHORT $LN167@inflateBac
  005a7	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  005aa	50		 push	 eax
  005ab	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  005ae	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  005b1	8b f0		 mov	 esi, eax
  005b3	83 c4 08	 add	 esp, 8
  005b6	85 f6		 test	 esi, esi
  005b8	0f 84 8e 07 00
	00		 je	 $LN363@inflateBac
  005be	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  005c1	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN167@inflateBac:
  005c4	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  005c7	8b cf		 mov	 ecx, edi
  005c9	d3 e0		 shl	 eax, cl
  005cb	43		 inc	 ebx
  005cc	8b 4d d4	 mov	 ecx, DWORD PTR tv1675[ebp]
  005cf	03 d0		 add	 edx, eax
  005d1	83 c7 08	 add	 edi, 8
  005d4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  005d7	4e		 dec	 esi
  005d8	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  005db	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  005de	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  005e1	3b f8		 cmp	 edi, eax
  005e3	72 be		 jb	 SHORT $LL173@inflateBac
$LN175@inflateBac:

; 424  :                         DROPBITS(here.bits);

  005e5	d3 ea		 shr	 edx, cl

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);

  005e7	8b c2		 mov	 eax, edx
  005e9	83 e0 07	 and	 eax, 7
  005ec	83 c0 03	 add	 eax, 3

; 427  :                         DROPBITS(3);

  005ef	c1 ea 03	 shr	 edx, 3
  005f2	89 45 e0	 mov	 DWORD PTR _copy$4$[ebp], eax
  005f5	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 428  :                     }
; 429  :                     else {

  005fa	eb 61		 jmp	 SHORT $LN494@inflateBac
$LN156@inflateBac:

; 430  :                         NEEDBITS(here.bits + 7);

  005fc	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  005ff	89 4d d4	 mov	 DWORD PTR tv1674[ebp], ecx
  00602	3b f8		 cmp	 edi, eax
  00604	73 42		 jae	 SHORT $LN155@inflateBac
$LL153@inflateBac:
  00606	85 f6		 test	 esi, esi
  00608	75 1d		 jne	 SHORT $LN147@inflateBac
  0060a	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0060d	50		 push	 eax
  0060e	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00611	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00614	8b f0		 mov	 esi, eax
  00616	83 c4 08	 add	 esp, 8
  00619	85 f6		 test	 esi, esi
  0061b	0f 84 2b 07 00
	00		 je	 $LN363@inflateBac
  00621	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00624	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN147@inflateBac:
  00627	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0062a	8b cf		 mov	 ecx, edi
  0062c	d3 e0		 shl	 eax, cl
  0062e	43		 inc	 ebx
  0062f	8b 4d d4	 mov	 ecx, DWORD PTR tv1674[ebp]
  00632	03 d0		 add	 edx, eax
  00634	83 c7 08	 add	 edi, 8
  00637	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0063a	4e		 dec	 esi
  0063b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0063e	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00641	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00644	3b f8		 cmp	 edi, eax
  00646	72 be		 jb	 SHORT $LL153@inflateBac
$LN155@inflateBac:

; 431  :                         DROPBITS(here.bits);

  00648	d3 ea		 shr	 edx, cl

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);

  0064a	8b c2		 mov	 eax, edx
  0064c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0064f	83 c0 0b	 add	 eax, 11			; 0000000bH

; 434  :                         DROPBITS(7);

  00652	c1 ea 07	 shr	 edx, 7
  00655	89 45 e0	 mov	 DWORD PTR _copy$4$[ebp], eax
  00658	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN494@inflateBac:
  0065d	2b c1		 sub	 eax, ecx
  0065f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00662	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00665	03 f8		 add	 edi, eax
  00667	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _len$1$[ebp], 0
$LN493@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  0066e	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  00671	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00674	03 4d e0	 add	 ecx, DWORD PTR _copy$4$[ebp]
  00677	03 42 64	 add	 eax, DWORD PTR [edx+100]
  0067a	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0067d	3b c8		 cmp	 ecx, eax
  0067f	77 5f		 ja	 SHORT $LN374@inflateBac

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  00681	8b 4d e0	 mov	 ecx, DWORD PTR _copy$4$[ebp]
  00684	85 c9		 test	 ecx, ecx
  00686	74 1c		 je	 SHORT $LN400@inflateBac
  00688	8b 5d dc	 mov	 ebx, DWORD PTR _len$1$[ebp]
  0068b	eb 03 8d 49 00	 npad	 5
$LL136@inflateBac:

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00690	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00693	66 89 5c 42 74	 mov	 WORD PTR [edx+eax*2+116], bx
  00698	ff 42 6c	 inc	 DWORD PTR [edx+108]
  0069b	49		 dec	 ecx
  0069c	75 f2		 jne	 SHORT $LL136@inflateBac
$LN492@inflateBac:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  0069e	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  006a1	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN400@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  006a4	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  006a7	03 42 64	 add	 eax, DWORD PTR [edx+100]
  006aa	39 42 6c	 cmp	 DWORD PTR [edx+108], eax
  006ad	0f 82 7d fd ff
	ff		 jb	 $LL217@inflateBac
$LN216@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  006b3	81 7a 04 51 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16209 ; 00003f51H
  006ba	0f 84 5d 06 00
	00		 je	 $LN482@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  006c0	66 83 ba 74 02
	00 00 00	 cmp	 WORD PTR [edx+628], 0
  006c8	75 2c		 jne	 SHORT $LN133@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  006ca	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006cd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;

  006d4	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 453  :                 break;

  006db	e9 37 06 00 00	 jmp	 $LN495@inflateBac
$LN374@inflateBac:

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  006e0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006e3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 415  :                             state->mode = BAD;

  006ea	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 416  :                             break;

  006f1	e9 21 06 00 00	 jmp	 $LN495@inflateBac
$LN133@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  006f6	8d 82 34 05 00
	00		 lea	 eax, DWORD PTR [edx+1332]

; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;

  006fc	c7 42 58 09 00
	00 00		 mov	 DWORD PTR [edx+88], 9
  00703	8d 5a 70	 lea	 ebx, DWORD PTR [edx+112]
  00706	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00709	8d 8a f4 02 00
	00		 lea	 ecx, DWORD PTR [edx+756]
  0070f	89 03		 mov	 DWORD PTR [ebx], eax
  00711	51		 push	 ecx
  00712	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00715	b9 01 00 00 00	 mov	 ecx, 1
  0071a	50		 push	 eax
  0071b	53		 push	 ebx
  0071c	ff 72 64	 push	 DWORD PTR [edx+100]
  0071f	8b 55 d0	 mov	 edx, DWORD PTR tv1685[ebp]
  00722	e8 00 00 00 00	 call	 _inflate_table
  00727	83 c4 10	 add	 esp, 16			; 00000010H

; 464  :             if (ret) {

  0072a	85 c0		 test	 eax, eax
  0072c	74 19		 je	 SHORT $LN132@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  0072e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 466  :                 state->mode = BAD;

  00731	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00734	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  0073b	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 467  :                 break;

  00742	e9 d0 05 00 00	 jmp	 $LN495@inflateBac
$LN132@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  00747	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0074a	8b 03		 mov	 eax, DWORD PTR [ebx]

; 470  :             state->distbits = 6;

  0074c	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  00753	8d 91 f4 02 00
	00		 lea	 edx, DWORD PTR [ecx+756]
  00759	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  0075c	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  0075f	52		 push	 edx
  00760	50		 push	 eax
  00761	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00764	53		 push	 ebx
  00765	ff 71 68	 push	 DWORD PTR [ecx+104]
  00768	83 c1 74	 add	 ecx, 116		; 00000074H
  0076b	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0076e	b9 02 00 00 00	 mov	 ecx, 2
  00773	e8 00 00 00 00	 call	 _inflate_table

; 475  :                 state->mode = BAD;

  00778	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0077b	83 c4 10	 add	 esp, 16			; 00000010H

; 476  :                 break;

  0077e	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  00781	85 c0		 test	 eax, eax
  00783	74 1c		 je	 SHORT $LN131@inflateBac

; 473  :             if (ret) {
; 474  :                 strm->msg = (char *)"invalid distances set";

  00785	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00788	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;

  0078f	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 476  :                 break;

  00796	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00799	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0079c	e9 7f 05 00 00	 jmp	 $LN387@inflateBac
$LN131@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  007a1	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
  007a8	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  007ab	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN130@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  007ae	83 fe 06	 cmp	 esi, 6
  007b1	0f 82 88 00 00
	00		 jb	 $LN353@inflateBac
  007b7	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  007be	72 7f		 jb	 SHORT $LN353@inflateBac

; 484  :                 RESTORE();

  007c0	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007c3	8b 45 e4	 mov	 eax, DWORD PTR _put$1$[ebp]
  007c6	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  007c9	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  007cc	89 42 10	 mov	 DWORD PTR [edx+16], eax
  007cf	8b c2		 mov	 eax, edx
  007d1	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  007d4	89 18		 mov	 DWORD PTR [eax], ebx
  007d6	8b d8		 mov	 ebx, eax
  007d8	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  007db	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 485  :                 if (state->whave < state->wsize)

  007de	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  007e1	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  007e4	39 4a 30	 cmp	 DWORD PTR [edx+48], ecx
  007e7	73 08		 jae	 SHORT $LN125@inflateBac

; 486  :                     state->whave = state->wsize - left;

  007e9	8b c1		 mov	 eax, ecx
  007eb	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  007ee	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN125@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  007f1	51		 push	 ecx
  007f2	53		 push	 ebx
  007f3	e8 00 00 00 00	 call	 _inflate_fast

; 488  :                 LOAD();

  007f8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  007fb	83 c4 08	 add	 esp, 8
  007fe	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00801	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00804	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00807	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00809	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  0080c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0080f	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00812	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00815	8b 7a 40	 mov	 edi, DWORD PTR [edx+64]
  00818	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0081b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0081e	89 4d fc	 mov	 DWORD PTR _hold$1$[ebp], ecx
  00821	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 489  :                 break;

  00824	e9 f7 04 00 00	 jmp	 $LN387@inflateBac
$LN239@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  00829	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0082c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;

  00833	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 371  :                 break;

  0083a	e9 d8 04 00 00	 jmp	 $LN495@inflateBac
$LN353@inflateBac:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  0083f	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00842	ba 01 00 00 00	 mov	 edx, 1
  00847	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0084a	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0084d	d3 e2		 shl	 edx, cl
  0084f	4a		 dec	 edx
  00850	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00853	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00856	8b c8		 mov	 ecx, eax
  00858	c1 e9 08	 shr	 ecx, 8
  0085b	0f b6 c9	 movzx	 ecx, cl
  0085e	3b cf		 cmp	 ecx, edi
  00860	76 59		 jbe	 SHORT $LN376@inflateBac
$LL121@inflateBac:

; 496  :                 PULLBYTE();

  00862	85 f6		 test	 esi, esi
  00864	75 1a		 jne	 SHORT $LN114@inflateBac
  00866	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00869	50		 push	 eax
  0086a	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0086d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00870	8b f0		 mov	 esi, eax
  00872	83 c4 08	 add	 esp, 8
  00875	85 f6		 test	 esi, esi
  00877	0f 84 cf 04 00
	00		 je	 $LN363@inflateBac
  0087d	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
$LN114@inflateBac:
  00880	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00883	8b cf		 mov	 ecx, edi
  00885	d3 e0		 shl	 eax, cl
  00887	43		 inc	 ebx
  00888	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  0088b	ba 01 00 00 00	 mov	 edx, 1
  00890	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00893	83 c7 08	 add	 edi, 8
  00896	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00899	4e		 dec	 esi
  0089a	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0089d	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  008a0	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  008a3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  008a6	d3 e2		 shl	 edx, cl
  008a8	4a		 dec	 edx
  008a9	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  008ac	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  008af	8b c8		 mov	 ecx, eax
  008b1	c1 e9 08	 shr	 ecx, 8
  008b4	0f b6 c9	 movzx	 ecx, cl
  008b7	3b cf		 cmp	 ecx, edi
  008b9	77 a7		 ja	 SHORT $LL121@inflateBac
$LN376@inflateBac:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  008bb	84 c0		 test	 al, al
  008bd	0f 84 d3 00 00
	00		 je	 $LN480@inflateBac
  008c3	a8 f0		 test	 al, 240			; 000000f0H
  008c5	0f 85 cb 00 00
	00		 jne	 $LN480@inflateBac

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  008cb	8b c8		 mov	 ecx, eax
  008cd	bb 01 00 00 00	 mov	 ebx, 1
  008d2	c1 e9 08	 shr	 ecx, 8
  008d5	8b d0		 mov	 edx, eax
  008d7	0f b6 f9	 movzx	 edi, cl
  008da	89 4d d0	 mov	 DWORD PTR tv1684[ebp], ecx
  008dd	0f b6 c8	 movzx	 ecx, al
  008e0	03 cf		 add	 ecx, edi
  008e2	c1 e8 10	 shr	 eax, 16			; 00000010H
  008e5	d3 e3		 shl	 ebx, cl
  008e7	8b cf		 mov	 ecx, edi
  008e9	4b		 dec	 ebx
  008ea	89 55 e0	 mov	 DWORD PTR _last$[ebp], edx
  008ed	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  008f0	d3 eb		 shr	 ebx, cl
  008f2	03 d8		 add	 ebx, eax
  008f4	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  008f7	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  008fa	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  008fd	8b c8		 mov	 ecx, eax
  008ff	c1 e9 08	 shr	 ecx, 8
  00902	0f b6 f9	 movzx	 edi, cl
  00905	8b 4d d0	 mov	 ecx, DWORD PTR tv1684[ebp]
  00908	0f b6 c9	 movzx	 ecx, cl
  0090b	03 f9		 add	 edi, ecx
  0090d	3b 7d ec	 cmp	 edi, DWORD PTR _bits$1$[ebp]
  00910	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00913	76 75		 jbe	 SHORT $LN98@inflateBac
$LL109@inflateBac:

; 504  :                     PULLBYTE();

  00915	85 f6		 test	 esi, esi
  00917	75 1f		 jne	 SHORT $LN476@inflateBac
  00919	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0091c	50		 push	 eax
  0091d	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00920	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00923	8b f0		 mov	 esi, eax
  00925	83 c4 08	 add	 esp, 8
  00928	85 f6		 test	 esi, esi
  0092a	0f 84 1c 04 00
	00		 je	 $LN363@inflateBac
  00930	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00933	8b 55 e0	 mov	 edx, DWORD PTR _last$[ebp]
  00936	eb 03		 jmp	 SHORT $LN102@inflateBac
$LN476@inflateBac:
  00938	8b 5d f0	 mov	 ebx, DWORD PTR _next$5$[ebp]
$LN102@inflateBac:
  0093b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0093e	8b cf		 mov	 ecx, edi
  00940	d3 e0		 shl	 eax, cl
  00942	83 c7 08	 add	 edi, 8
  00945	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00948	43		 inc	 ebx
  00949	0f b7 45 e2	 movzx	 eax, WORD PTR _last$[ebp+2]
  0094d	4e		 dec	 esi
  0094e	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00951	bf 01 00 00 00	 mov	 edi, 1
  00956	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00959	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0095c	0f b6 de	 movzx	 ebx, dh
  0095f	0f b6 ca	 movzx	 ecx, dl
  00962	03 cb		 add	 ecx, ebx
  00964	d3 e7		 shl	 edi, cl
  00966	8b cb		 mov	 ecx, ebx
  00968	4f		 dec	 edi
  00969	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0096c	d3 ef		 shr	 edi, cl
  0096e	03 f8		 add	 edi, eax
  00970	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00973	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00976	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00979	8b c8		 mov	 ecx, eax
  0097b	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  0097e	c1 e9 08	 shr	 ecx, 8
  00981	0f b6 c9	 movzx	 ecx, cl
  00984	03 cb		 add	 ecx, ebx
  00986	3b cf		 cmp	 ecx, edi
  00988	77 8b		 ja	 SHORT $LL109@inflateBac
$LN98@inflateBac:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  0098a	8b 5d fc	 mov	 ebx, DWORD PTR _hold$1$[ebp]
  0098d	0f b6 ce	 movzx	 ecx, dh
  00990	d3 eb		 shr	 ebx, cl
  00992	2b f9		 sub	 edi, ecx
  00994	eb 03		 jmp	 SHORT $LN96@inflateBac
$LN480@inflateBac:
  00996	8b 5d fc	 mov	 ebx, DWORD PTR _hold$1$[ebp]
$LN96@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);
; 509  :             state->length = (unsigned)here.val;

  00999	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0099c	8b c8		 mov	 ecx, eax
  0099e	c1 e9 08	 shr	 ecx, 8
  009a1	0f b6 c9	 movzx	 ecx, cl
  009a4	d3 eb		 shr	 ebx, cl
  009a6	2b f9		 sub	 edi, ecx
  009a8	8b c8		 mov	 ecx, eax
  009aa	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx
  009ad	c1 e9 10	 shr	 ecx, 16			; 00000010H
  009b0	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  009b3	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  009b6	84 c0		 test	 al, al
  009b8	75 45		 jne	 SHORT $LN92@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  009ba	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  009be	75 24		 jne	 SHORT $LN487@inflateBac
  009c0	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  009c3	8b 5a 38	 mov	 ebx, DWORD PTR [edx+56]
  009c6	50		 push	 eax
  009c7	53		 push	 ebx
  009c8	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  009cb	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  009ce	89 42 30	 mov	 DWORD PTR [edx+48], eax
  009d1	ff 55 14	 call	 DWORD PTR _out$[ebp]
  009d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  009d7	85 c0		 test	 eax, eax
  009d9	0f 85 87 03 00
	00		 jne	 $LN366@inflateBac
  009df	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  009e2	eb 03		 jmp	 SHORT $LN90@inflateBac
$LN487@inflateBac:
  009e4	8b 5d e4	 mov	 ebx, DWORD PTR _put$1$[ebp]
$LN90@inflateBac:

; 517  :                 *put++ = (unsigned char)(state->length);

  009e7	8a 42 44	 mov	 al, BYTE PTR [edx+68]
  009ea	88 03		 mov	 BYTE PTR [ebx], al
  009ec	43		 inc	 ebx

; 518  :                 left--;

  009ed	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  009f0	89 5d e4	 mov	 DWORD PTR _put$1$[ebp], ebx

; 519  :                 state->mode = LEN;

  009f3	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H

; 520  :                 break;

  009fa	e9 18 03 00 00	 jmp	 $LN495@inflateBac
$LN92@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  009ff	a8 20		 test	 al, 32			; 00000020H
  00a01	74 0c		 je	 SHORT $LN86@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00a03	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 527  :                 break;

  00a0a	e9 08 03 00 00	 jmp	 $LN495@inflateBac
$LN86@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00a0f	a8 40		 test	 al, 64			; 00000040H
  00a11	74 16		 je	 SHORT $LN85@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00a13	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a16	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 533  :                 state->mode = BAD;

  00a1d	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 534  :                 break;

  00a24	e9 ee 02 00 00	 jmp	 $LN495@inflateBac
$LN85@inflateBac:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00a29	0f b6 c0	 movzx	 eax, al
  00a2c	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a2f	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 539  :             if (state->extra != 0) {

  00a32	74 60		 je	 SHORT $LN68@inflateBac

; 540  :                 NEEDBITS(state->extra);

  00a34	3b f8		 cmp	 edi, eax
  00a36	73 42		 jae	 SHORT $LN82@inflateBac
  00a38	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00a3b	eb 03 8d 49 00	 npad	 5
$LL80@inflateBac:
  00a40	85 f6		 test	 esi, esi
  00a42	75 1d		 jne	 SHORT $LN74@inflateBac
  00a44	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00a47	50		 push	 eax
  00a48	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00a4b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00a4e	8b f0		 mov	 esi, eax
  00a50	83 c4 08	 add	 esp, 8
  00a53	85 f6		 test	 esi, esi
  00a55	0f 84 f1 02 00
	00		 je	 $LN363@inflateBac
  00a5b	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00a5e	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
$LN74@inflateBac:
  00a61	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00a64	8b cf		 mov	 ecx, edi
  00a66	d3 e0		 shl	 eax, cl
  00a68	83 c7 08	 add	 edi, 8
  00a6b	03 d8		 add	 ebx, eax
  00a6d	4e		 dec	 esi
  00a6e	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00a71	40		 inc	 eax
  00a72	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00a75	3b 7a 4c	 cmp	 edi, DWORD PTR [edx+76]
  00a78	72 c6		 jb	 SHORT $LL80@inflateBac
$LN82@inflateBac:

; 541  :                 state->length += BITS(state->extra);

  00a7a	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00a7d	b8 01 00 00 00	 mov	 eax, 1
  00a82	d3 e0		 shl	 eax, cl
  00a84	48		 dec	 eax
  00a85	23 c3		 and	 eax, ebx

; 542  :                 DROPBITS(state->extra);

  00a87	d3 eb		 shr	 ebx, cl
  00a89	01 42 44	 add	 DWORD PTR [edx+68], eax
  00a8c	2b f9		 sub	 edi, ecx
  00a8e	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx
  00a91	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
$LN68@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00a94	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00a97	ba 01 00 00 00	 mov	 edx, 1
  00a9c	8b 4b 5c	 mov	 ecx, DWORD PTR [ebx+92]
  00a9f	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00aa2	d3 e2		 shl	 edx, cl
  00aa4	4a		 dec	 edx
  00aa5	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00aa8	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00aab	8b c8		 mov	 ecx, eax
  00aad	c1 e9 08	 shr	 ecx, 8
  00ab0	0f b6 c9	 movzx	 ecx, cl
  00ab3	3b cf		 cmp	 ecx, edi
  00ab5	76 53		 jbe	 SHORT $LN469@inflateBac
$LL67@inflateBac:

; 550  :                 PULLBYTE();

  00ab7	85 f6		 test	 esi, esi
  00ab9	75 17		 jne	 SHORT $LN60@inflateBac
  00abb	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00abe	50		 push	 eax
  00abf	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00ac2	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00ac5	8b f0		 mov	 esi, eax
  00ac7	83 c4 08	 add	 esp, 8
  00aca	85 f6		 test	 esi, esi
  00acc	0f 84 7a 02 00
	00		 je	 $LN363@inflateBac
$LN60@inflateBac:
  00ad2	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00ad5	8b cf		 mov	 ecx, edi
  00ad7	83 c7 08	 add	 edi, 8
  00ada	4e		 dec	 esi
  00adb	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00ade	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ae1	42		 inc	 edx
  00ae2	d3 e0		 shl	 eax, cl
  00ae4	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00ae7	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00aea	ba 01 00 00 00	 mov	 edx, 1
  00aef	8b 4b 5c	 mov	 ecx, DWORD PTR [ebx+92]
  00af2	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00af5	d3 e2		 shl	 edx, cl
  00af7	4a		 dec	 edx
  00af8	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00afb	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00afe	8b c8		 mov	 ecx, eax
  00b00	c1 e9 08	 shr	 ecx, 8
  00b03	0f b6 c9	 movzx	 ecx, cl
  00b06	3b cf		 cmp	 ecx, edi
  00b08	77 ad		 ja	 SHORT $LL67@inflateBac
$LN469@inflateBac:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00b0a	a8 f0		 test	 al, 240			; 000000f0H
  00b0c	0f 85 c7 00 00
	00		 jne	 $LN481@inflateBac

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00b12	8b c8		 mov	 ecx, eax
  00b14	bb 01 00 00 00	 mov	 ebx, 1
  00b19	c1 e9 08	 shr	 ecx, 8
  00b1c	8b d0		 mov	 edx, eax
  00b1e	0f b6 f9	 movzx	 edi, cl
  00b21	89 4d d0	 mov	 DWORD PTR tv1683[ebp], ecx
  00b24	0f b6 c8	 movzx	 ecx, al
  00b27	03 cf		 add	 ecx, edi
  00b29	c1 e8 10	 shr	 eax, 16			; 00000010H
  00b2c	d3 e3		 shl	 ebx, cl
  00b2e	8b cf		 mov	 ecx, edi
  00b30	4b		 dec	 ebx
  00b31	89 55 e0	 mov	 DWORD PTR _last$[ebp], edx
  00b34	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00b37	d3 eb		 shr	 ebx, cl
  00b39	03 d8		 add	 ebx, eax
  00b3b	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b3e	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  00b41	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00b44	8b c8		 mov	 ecx, eax
  00b46	c1 e9 08	 shr	 ecx, 8
  00b49	0f b6 f9	 movzx	 edi, cl
  00b4c	8b 4d d0	 mov	 ecx, DWORD PTR tv1683[ebp]
  00b4f	0f b6 c9	 movzx	 ecx, cl
  00b52	03 f9		 add	 edi, ecx
  00b54	3b 7d ec	 cmp	 edi, DWORD PTR _bits$1$[ebp]
  00b57	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00b5a	76 71		 jbe	 SHORT $LN44@inflateBac
  00b5c	8d 64 24 00	 npad	 4
$LL55@inflateBac:

; 558  :                     PULLBYTE();

  00b60	85 f6		 test	 esi, esi
  00b62	75 1a		 jne	 SHORT $LN48@inflateBac
  00b64	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00b67	50		 push	 eax
  00b68	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00b6b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00b6e	8b f0		 mov	 esi, eax
  00b70	83 c4 08	 add	 esp, 8
  00b73	85 f6		 test	 esi, esi
  00b75	0f 84 d1 01 00
	00		 je	 $LN363@inflateBac
  00b7b	8b 55 e0	 mov	 edx, DWORD PTR _last$[ebp]
$LN48@inflateBac:
  00b7e	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00b81	8b cf		 mov	 ecx, edi
  00b83	83 c7 08	 add	 edi, 8
  00b86	4e		 dec	 esi
  00b87	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00b8a	bf 01 00 00 00	 mov	 edi, 1
  00b8f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00b92	43		 inc	 ebx
  00b93	d3 e0		 shl	 eax, cl
  00b95	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00b98	0f b7 45 e2	 movzx	 eax, WORD PTR _last$[ebp+2]
  00b9c	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00b9f	0f b6 de	 movzx	 ebx, dh
  00ba2	0f b6 ca	 movzx	 ecx, dl
  00ba5	03 cb		 add	 ecx, ebx
  00ba7	d3 e7		 shl	 edi, cl
  00ba9	8b cb		 mov	 ecx, ebx
  00bab	4f		 dec	 edi
  00bac	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  00baf	d3 ef		 shr	 edi, cl
  00bb1	03 f8		 add	 edi, eax
  00bb3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb6	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  00bb9	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00bbc	8b c8		 mov	 ecx, eax
  00bbe	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00bc1	c1 e9 08	 shr	 ecx, 8
  00bc4	0f b6 c9	 movzx	 ecx, cl
  00bc7	03 cb		 add	 ecx, ebx
  00bc9	3b cf		 cmp	 ecx, edi
  00bcb	77 93		 ja	 SHORT $LL55@inflateBac
$LN44@inflateBac:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00bcd	8b 5d fc	 mov	 ebx, DWORD PTR _hold$1$[ebp]
  00bd0	0f b6 ce	 movzx	 ecx, dh
  00bd3	d3 eb		 shr	 ebx, cl
  00bd5	2b f9		 sub	 edi, ecx
  00bd7	eb 03		 jmp	 SHORT $LN42@inflateBac
$LN481@inflateBac:
  00bd9	8b 5d fc	 mov	 ebx, DWORD PTR _hold$1$[ebp]
$LN42@inflateBac:

; 565  :                 state->mode = BAD;

  00bdc	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00bdf	8b c8		 mov	 ecx, eax
  00be1	c1 e9 08	 shr	 ecx, 8
  00be4	0f b6 c9	 movzx	 ecx, cl
  00be7	d3 eb		 shr	 ebx, cl
  00be9	2b f9		 sub	 edi, ecx
  00beb	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx
  00bee	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00bf1	a8 40		 test	 al, 64			; 00000040H
  00bf3	74 16		 je	 SHORT $LN38@inflateBac

; 561  :             }
; 562  :             DROPBITS(here.bits);
; 563  :             if (here.op & 64) {
; 564  :                 strm->msg = (char *)"invalid distance code";

  00bf5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00bf8	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 565  :                 state->mode = BAD;

  00bff	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 566  :                 break;

  00c06	e9 0c 01 00 00	 jmp	 $LN495@inflateBac
$LN38@inflateBac:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00c0b	8b c8		 mov	 ecx, eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00c0d	0f b6 c0	 movzx	 eax, al
  00c10	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c13	83 e0 0f	 and	 eax, 15			; 0000000fH
  00c16	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  00c19	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 572  :             if (state->extra != 0) {

  00c1c	74 5b		 je	 SHORT $LN21@inflateBac

; 573  :                 NEEDBITS(state->extra);

  00c1e	3b f8		 cmp	 edi, eax
  00c20	73 3d		 jae	 SHORT $LN35@inflateBac
  00c22	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
$LL33@inflateBac:
  00c25	85 f6		 test	 esi, esi
  00c27	75 1d		 jne	 SHORT $LN27@inflateBac
  00c29	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00c2c	50		 push	 eax
  00c2d	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00c30	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00c33	8b f0		 mov	 esi, eax
  00c35	83 c4 08	 add	 esp, 8
  00c38	85 f6		 test	 esi, esi
  00c3a	0f 84 0c 01 00
	00		 je	 $LN363@inflateBac
  00c40	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00c43	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
$LN27@inflateBac:
  00c46	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00c49	8b cf		 mov	 ecx, edi
  00c4b	d3 e0		 shl	 eax, cl
  00c4d	83 c7 08	 add	 edi, 8
  00c50	03 d8		 add	 ebx, eax
  00c52	4e		 dec	 esi
  00c53	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00c56	40		 inc	 eax
  00c57	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00c5a	3b 7a 4c	 cmp	 edi, DWORD PTR [edx+76]
  00c5d	72 c6		 jb	 SHORT $LL33@inflateBac
$LN35@inflateBac:

; 574  :                 state->offset += BITS(state->extra);

  00c5f	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00c62	b8 01 00 00 00	 mov	 eax, 1
  00c67	d3 e0		 shl	 eax, cl
  00c69	48		 dec	 eax
  00c6a	23 c3		 and	 eax, ebx

; 575  :                 DROPBITS(state->extra);

  00c6c	d3 eb		 shr	 ebx, cl
  00c6e	01 42 48	 add	 DWORD PTR [edx+72], eax
  00c71	2b f9		 sub	 edi, ecx
  00c73	89 5d fc	 mov	 DWORD PTR _hold$1$[ebp], ebx
  00c76	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
$LN21@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  00c79	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00c7c	39 4a 30	 cmp	 DWORD PTR [edx+48], ecx
  00c7f	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  00c82	1b c0		 sbb	 eax, eax
  00c84	23 c3		 and	 eax, ebx
  00c86	2b c8		 sub	 ecx, eax
  00c88	39 4a 48	 cmp	 DWORD PTR [edx+72], ecx
  00c8b	76 13		 jbe	 SHORT $LL19@inflateBac

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00c8d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c90	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;

  00c97	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 581  :                 break;

  00c9e	eb 77		 jmp	 SHORT $LN495@inflateBac
$LL19@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00ca0	85 db		 test	 ebx, ebx
  00ca2	75 27		 jne	 SHORT $LN488@inflateBac
  00ca4	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00ca7	8b 5a 38	 mov	 ebx, DWORD PTR [edx+56]
  00caa	50		 push	 eax
  00cab	53		 push	 ebx
  00cac	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00caf	89 5d e4	 mov	 DWORD PTR _put$1$[ebp], ebx
  00cb2	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  00cb5	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00cb8	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00cbb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cbe	85 c0		 test	 eax, eax
  00cc0	0f 85 a0 00 00
	00		 jne	 $LN366@inflateBac
  00cc6	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00cc9	eb 03		 jmp	 SHORT $LN15@inflateBac
$LN488@inflateBac:
  00ccb	8b 5d e4	 mov	 ebx, DWORD PTR _put$1$[ebp]
$LN15@inflateBac:

; 588  :                 copy = state->wsize - state->offset;

  00cce	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00cd1	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00cd4	2b c1		 sub	 eax, ecx

; 589  :                 if (copy < left) {

  00cd6	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  00cd9	73 09		 jae	 SHORT $LN11@inflateBac

; 590  :                     from = put + copy;
; 591  :                     copy = left - copy;

  00cdb	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00cde	03 d8		 add	 ebx, eax
  00ce0	2b c8		 sub	 ecx, eax

; 592  :                 }
; 593  :                 else {

  00ce2	eb 05		 jmp	 SHORT $LN10@inflateBac
$LN11@inflateBac:

; 594  :                     from = put - state->offset;

  00ce4	2b d9		 sub	 ebx, ecx

; 595  :                     copy = left;

  00ce6	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
$LN10@inflateBac:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00ce9	3b 4a 44	 cmp	 ecx, DWORD PTR [edx+68]
  00cec	0f 47 4a 44	 cmova	 ecx, DWORD PTR [edx+68]

; 598  :                 state->length -= copy;

  00cf0	29 4a 44	 sub	 DWORD PTR [edx+68], ecx

; 599  :                 left -= copy;

  00cf3	29 4d e8	 sub	 DWORD PTR _left$1$[ebp], ecx

; 602  :                 } while (--copy);

  00cf6	8b 55 e4	 mov	 edx, DWORD PTR _put$1$[ebp]
  00cf9	2b da		 sub	 ebx, edx
  00cfb	eb 03 8d 49 00	 npad	 5
$LL8@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00d00	8a 04 13	 mov	 al, BYTE PTR [ebx+edx]
  00d03	88 02		 mov	 BYTE PTR [edx], al
  00d05	42		 inc	 edx

; 602  :                 } while (--copy);

  00d06	49		 dec	 ecx
  00d07	75 f7		 jne	 SHORT $LL8@inflateBac

; 603  :             } while (state->length != 0);

  00d09	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  00d0c	89 55 e4	 mov	 DWORD PTR _put$1$[ebp], edx
  00d0f	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00d12	39 4a 44	 cmp	 DWORD PTR [edx+68], ecx
  00d15	75 89		 jne	 SHORT $LL19@inflateBac
$LN495@inflateBac:
  00d17	8b 5d f8	 mov	 ebx, DWORD PTR _next$[ebp]
  00d1a	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN482@inflateBac:
  00d1d	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
$LN387@inflateBac:

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00d20	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00d23	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00d28	83 f8 12	 cmp	 eax, 18			; 00000012H
  00d2b	0f 86 4f f3 ff
	ff		 jbe	 $LL332@inflateBac
$LN1@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00d31	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN475@inflateBac:
  00d36	8b 45 f0	 mov	 eax, DWORD PTR _next$5$[ebp]
$inf_leave$499:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00d39	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d3c	89 01		 mov	 DWORD PTR [ecx], eax

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00d3e	8b c7		 mov	 eax, edi
  00d40	5f		 pop	 edi
  00d41	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00d44	5e		 pop	 esi
  00d45	5b		 pop	 ebx

; 629  : }

  00d46	8b e5		 mov	 esp, ebp
  00d48	5d		 pop	 ebp
  00d49	c2 14 00	 ret	 20			; 00000014H
$LN363@inflateBac:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00d4c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d4f	33 c0		 xor	 eax, eax
  00d51	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00d56	89 01		 mov	 DWORD PTR [ecx], eax

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00d58	8b c7		 mov	 eax, edi
  00d5a	5f		 pop	 edi
  00d5b	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00d5e	5e		 pop	 esi
  00d5f	5b		 pop	 ebx

; 629  : }

  00d60	8b e5		 mov	 esp, ebp
  00d62	5d		 pop	 ebp
  00d63	c2 14 00	 ret	 20			; 00000014H
$LN366@inflateBac:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00d66	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d69	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00d6e	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00d71	89 01		 mov	 DWORD PTR [ecx], eax

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00d73	8b c7		 mov	 eax, edi
  00d75	5f		 pop	 edi
  00d76	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00d79	5e		 pop	 esi
  00d7a	5b		 pop	 ebx

; 629  : }

  00d7b	8b e5		 mov	 esp, ebp
  00d7d	5d		 pop	 ebp
  00d7e	c2 14 00	 ret	 20			; 00000014H
$LN5@inflateBac:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00d81	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00d84	bf 01 00 00 00	 mov	 edi, 1
  00d89	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00d8c	3b c8		 cmp	 ecx, eax
  00d8e	73 a6		 jae	 SHORT $LN475@inflateBac

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00d90	2b c1		 sub	 eax, ecx
  00d92	50		 push	 eax
  00d93	ff 72 38	 push	 DWORD PTR [edx+56]
  00d96	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00d99	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00d9c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d9f	85 c0		 test	 eax, eax

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;

  00da1	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00da4	74 93		 je	 SHORT $inf_leave$499

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00da6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00da9	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00dae	89 01		 mov	 DWORD PTR [ecx], eax

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00db0	8b c7		 mov	 eax, edi
  00db2	5f		 pop	 edi
  00db3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00db6	5e		 pop	 esi
  00db7	5b		 pop	 ebx

; 629  : }

  00db8	8b e5		 mov	 esp, ebp
  00dba	5d		 pop	 ebp
  00dbb	c2 14 00	 ret	 20			; 00000014H
$LN2@inflateBac:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00dbe	bf fd ff ff ff	 mov	 edi, -3			; fffffffdH

; 617  :             goto inf_leave;

  00dc3	e9 6e ff ff ff	 jmp	 $LN475@inflateBac
$LN333@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00dc8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 629  : }

  00dcd	8b e5		 mov	 esp, ebp
  00dcf	5d		 pop	 ebp
  00dd0	c2 14 00	 ret	 20			; 00000014H
  00dd3	90		 npad	 1
$LN497@inflateBac:
  00dd4	00 00 00 00	 DD	 $LN328@inflateBac
  00dd8	00 00 00 00	 DD	 $LN297@inflateBac
  00ddc	00 00 00 00	 DD	 $LN262@inflateBac
  00de0	00 00 00 00	 DD	 $LN130@inflateBac
  00de4	00 00 00 00	 DD	 $LN5@inflateBac
  00de8	00 00 00 00	 DD	 $LN2@inflateBac
  00dec	00 00 00 00	 DD	 $LN1@inflateBac
$LN465@inflateBac:
  00df0	00		 DB	 0
  00df1	06		 DB	 6
  00df2	01		 DB	 1
  00df3	06		 DB	 6
  00df4	06		 DB	 6
  00df5	02		 DB	 2
  00df6	06		 DB	 6
  00df7	06		 DB	 6
  00df8	06		 DB	 6
  00df9	03		 DB	 3
  00dfa	06		 DB	 6
  00dfb	06		 DB	 6
  00dfc	06		 DB	 6
  00dfd	06		 DB	 6
  00dfe	06		 DB	 6
  00dff	06		 DB	 6
  00e00	06		 DB	 6
  00e01	04		 DB	 4
  00e02	05		 DB	 5
  00e03	90		 npad	 1
$LN498@inflateBac:
  00e04	00 00 00 00	 DD	 $LN305@inflateBac
  00e08	00 00 00 00	 DD	 $LN304@inflateBac
  00e0c	00 00 00 00	 DD	 $LN303@inflateBac
  00e10	00 00 00 00	 DD	 $LN302@inflateBac
_inflateBack@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\git\image2geometry\3rdparty\zlib-1.2.11\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@inflateBac
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 1e		 je	 SHORT $LN1@inflateBac
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 17		 je	 SHORT $LN1@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00019	50		 push	 eax
  0001a	ff 76 28	 push	 DWORD PTR [esi+40]
  0001d	ff d1		 call	 ecx
  0001f	83 c4 08	 add	 esp, 8

; 637  :     strm->state = Z_NULL;

  00022	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 640  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	5e		 pop	 esi

; 640  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
_TEXT	ENDS
END
